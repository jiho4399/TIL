[toc]

# 시간 복잡도, 빅오 표기법

## 1. 자료구조와 알고리즘

### [1] 자료와 자료구조

#### (1) 자료(Data)

- `저장공간(메모리)에 저장되는 데이터`를 뜻합니다.
- 데이터는 int, float 처럼 특정 타입을 가질 수 있습니다.

#### (2) 자료구조(Data Structure)

- 데이터를 `저장`하는 기능 뿐 아니라, 읽기/쓰기/삽입/삭제와 같은 `연산`도 제공합니다.
- `list, set, dict, stack, queue 등`은 데이터를 저장할 뿐만 아니라, 메서드를 통해서 저장된 데이터를 조작할 수 있는 기능도 제공하므로 자료구조라고 할 수 있습니다.
- 하지만 `int, float`은 데이터를 저장할 수만 있으므로 이들은 자료구조라고 하지는 않습니다.

```
 **자료구조는 알고리즘의 재료가 됩니다!**
    - 데이터를 조작할 수 있는 자료구조로 인해 더 효율적인 알고리즘을 구현할 수 			있습니다.
    - 자료구조는 재료, 알고리즘은 요리입니다. 자료구조를 모르면 알고리즘을 					알 수 없습니다.
```

### [2] 알고리즘

1. 알고리즘은 Black Box 입니다.

   - Input을 넣었을 때 원하는 Output이 나오도록 하는 Code

   - 각 자료구조의 특성을 적절하게 사용하면 

     훨씬 효율적인 알고리즘을 구현할 수 있다.

2. 좋은 알고리즘이란?

   - 효율성 좋은 알고리즘 = 성능이 좋은 알고리즘
   - Input을 넣은 후 Output이 나오는 시간이 적은 알고리즘

## 2. 알고리즘의 시간 복잡도

- Input을 넣은 후 Output이 나오는 시간 측정하기

### [1] 실제 소요 시간을 측정하기- 첫번째 방법

- Input을 넣고 Output이 나올 때까지 몇 초가 걸리는지  

  직접 타이머로 측정하는 방법

- 개인의 컴퓨터마다 환경이 다르므로 수행시간이 달라짐

- 이는 객관적이지 못함

### [2] 알고리즘 내부의 연산 횟수를 측정하기- 두번째 방법

- 알고리즘 내부에서 기본 연산이 총 몇 번 수행되는지 그 횟수를 계산하기

  - `기본 연산` : 단위 시간 `1`이 소요되는 가장 기본적인 연산 

    (ex. 할당, 산술, 비교, 반환 등)

  - **기본 연산의 총 횟수 = 알고리즘의 총 소요 시간 **

- 예시
- word와 char라고 하는 input을 넣으면 total을 output으로 반환하는 알고리즘

```python
def count(word, char):
  total = 0
  for i in word:
    if i == char:
      total += 1
  return total
```

- 알고리즘의 수행 시간 = 내부에서 일어나는 할당, 비교, 산술, 반환 연산의 횟수
- word가  `apple` 일 때와 `abcdefghijklmnopqr` 일 때 연산 횟수가 같음

### [3] 최악의 입력 n개를 가정하고 수식을 구하기 - 두번째 방법 개선

-  입력을 최악의 경우로 통일 시키면 됩니다.
- 예시

```python
def count(word, char):
  total = 0
  for i in word:
    if i == char:
      total += 1
  return total
```

- 최악의 경우 : char가 `a` 일 때, word가`aaaaaaa` 와 같은 형식인 경우
  - 모든 if 문을 만족 시키므로 매 반복마다 total += 1 연산이 발생하기 때문
- 임의의 n개가 들어온다고 가정
- `입력 n에 대한 연산 횟수` 는 이제 객관적인 알고리즘 수행 시간의 지표가 됨

### [4] 시간 복잡도 (Tinme Complexity)

- 문제를 해결하는데 걸리는 시간과 입력의 함수 관계
- 입력 n에 따른 `알고리즘의 수행 시간` 을 의미
  - 시간 복잡도가 높으면 느린 알고리즘 !
  - 시간 복잡도가 낮으면 빠른 알고리즘 !

1. 6n + 4
2. 3n + 2
3. 3n^2 + 6n + 1

- 첫 번째와 두 번째 사람은 입력 n에 따른 시간 복잡도가 선형으로 증가
- 세 번째 사람은 입력 n에 따른 시간 복잡도가 제곱으로 증가 (이차함수)

- 여기서 포인트는 누가 느리냐 빠르냐가 아니라, 누가 입력 n에 따라 `증가율` 이 높냐 입니다.

## 3. 빅오(Big-O) 표기법

- 증가율에 직접적으로 관여하는 최고차항만 남기고 

  계수와 상수는 모두 지웁니다.

1. 6n + 4  ->  O(n)
2. 3n + 2  ->  O(n)
3. 3n^2 + 6n + 1  ->  O(n^2)

- 증가율이 동일하므로 해당 두 알고리즘의 성능은 거의 동일하다고 판단

- `O(1)`은 상수 시간으로써 가장 효율적인 알고리즘
- 입력 n이 아무리 많아져도 항상 빠르고 일정한 수행 시간을 보장



### [1] 문제에서 시간 복잡도 계산하기

- 문제 풀이 사이트에서는 `“초” 단위` 로 제한 시간이 주어집니다.
- 보통 `1초에 1억 번 연산`을 가정하고 계산을 합니다.

1. 먼저 제한 시간을 보고 가능한 총 연산 횟수를 짐작합니다. (제한 시간 x 1억)
2. 실제 `입력의 가장 큰 범위`에 따라 반복문을 몇 번까지 돌 수 있는지 계산합니다.
3. 가능한 총 연산 횟수를 넘어서 `시간 초과`가 나게 되면 풀이를 개선해야 합니다.

- 반복문 1번에 O(n)이라고 생각! (이중 for문은 O(n^2))

**실제 카카오 해설에서 언급된 시간 복잡도 (문제 1의 해설)**

[카카오 문제](https://tech.kakao.com/2021/01/25/2021-kakao-recruitment-round-1/)

### [2] 파이썬 내장 함수, 메서드의 시간 복잡도 알아두기

[파이썬 내장함수, 메서드 시간 복잡도1](https://www.ics.uci.edu/~pattis/ICS-33/lectures/complexitypython.txt)

[파이썬 내장함수, 메서드 시간 복잡도2](https://www.deviantart.com/assyrianic/art/Big-O-Notation-Cheat-Sheet-762169573)

- O(n)으로 풀면 될 것 같아서, for문을 1번만 작성했는데 시간 초과가 나는 경우
  - for문 내부에 작성한 내장 함수, 메서드 때문은 아닌지 확인
  - for문을 1번만 작성했더라도, 내부에 작성한 메서드가 O(n)의 시간 복잡도라면 이중 for문을 작성한 것과 다를게 없기 때문!!
- [참고](https://www.ics.uci.edu/~pattis/ICS-33/lectures/complexitypython.txt)

