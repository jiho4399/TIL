[toc]

# Numpy

## 1. 평균 구하기

```python
scoreList = [11, 12, 13, 14]
sumList = 0
avgList = 0

for score in scoreList :
  sumList += score

avgList = sumList / len(scoreList)

sumList, avgList
# (50, 12.5)
```

## 2. 기본값으로 점수 주고 시작하기

- 모두에게 1점씩 점수를 올려주어야 하는 상황

```python
scoreList2 = []

for score in scoreList :
  scoreList2.append(score + 1)

scoreList2
# [12, 13, 14, 15]
```

## 3. List Comprehension으로 10점 올려주기

```python
scoreList3 = [score + 10 for score in scoreList]

scoreList3
# [21, 22, 23, 24]
```

## 4. 2차원 리스트의 요소에 1을 더하기

- 차원 수 만큼 for문과 append를 실행해야 한다.

```python
lst = [[1,2,3], [4,5,6], [7,8,9]]

lst2 = []

for i in lst : #[1, 2, 3] 빼기
  a = []
  for j in i : # [1, 2, 3]에서 1, 2, 3 빼기
    a.append(j + 1) # 1, 2, 3에 1식 더하고 a로 묶기
    
  lst2.append(a) # a로 묶은 것을 다시 리스트 lst2에 묶기

lst2
# [[2, 3, 4], [5, 6, 7], [8, 9, 10]]
```

## 5. 본격적으로 Numpy 사용하기

```python
import numpy as np

scoreNdarray = np.array(lst)

scoreNdarray
```

### [1] 1 더하기

```python
scoreNdarray + 1

# array([[ 2,  3,  4],
#        [ 5,  6,  7],
#        [ 8,  9, 10]])
```

### [2] 행렬 형태 확인 `shape()` 

```python
a.shape
# (3, 4)

# 차원 확인
a.ndim
# 2
```

### [3] 평균과 합

```python
np.mean(scoreNdarray)
# 5.0
np.sum(scoreNdarray)
# 45
np.sum(scoreNdarray, axis=0)
# array([12, 15, 18])
np.sum(scoreNdarray, axis=1)
# array([ 6, 15, 24])
```

### [4] 0에서 1 사이의 값 난수 생성`rand()` 

```python
sample20 = np.random.rand(2, 2)
sample20
# array([[0.49191756, 0.38291382],
#       [0.72915478, 0.24098918]])
```

### [5] 2차원 리스트 만들기 `tolist()` 

```python
sample20List = sample20.tolist()
sample20List
# [[0.4919175581889068, 0.3829138156290033],
#  [0.7291547777277867, 0.24098918475000652]]
```

### [6] 행과 열 바꾸기 `transpose` 

```python
x = np.array([[1, 2], [3, 4]])
x
# array([[1, 2],
#        [3, 4]])

y = x.T
y
# array([[1, 3],
#        [2, 4]])
```

### [7] 행 간 이동시 값 차이, 열 간 이동시 값 차이 `strides` 

```python
x.strides
# (2, 1)
y.strides
# (1, 2)
```

### [8] 산술평균과 가중평균

```python
# 산술평균
np.mean(range(1, 11))
# 5.5

# 가중평균
np.average(range(1, 11), weights=(range(10, 0, -1)))
# 4.0
```

### [9] 쓰레기 값으로 만들어진 행렬 `empty` 

```python
np.empty((4, 3))

# array([[0.00000000e+000, 2.31297541e-312, 1.76125651e-312],
#        [1.37929726e-312, 2.41907520e-312, 2.56761491e-312],
#        [1.29441743e-312, 2.33419537e-312, 9.76118064e-313],
#        [9.96274716e-047, 3.99910963e+252, 1.46030983e-319]])
```

### [10] A의 모양 따라하기 `empty_like` 

```python
A = np.array([
              [1,2,3],
              [4,5,6],
              [7,8,9]
              ])

np.empty_like(A)
# array([[94836154557504,   137438953586,   502511173742],
#        [  137438953581,   472446402665,   463856468000],
#        [  498216206451,   249108103200,   249108103200]])
```

### [11] 0행렬 `zeros()` 

```python
np.zeros((2, 3))
# array([[0., 0., 0.],
#        [0., 0., 0.]])

np.zeros_like(A)
# array([[0, 0, 0],
#        [0, 0, 0],
#        [0, 0, 0]])
```

### [12] 1 행렬 `ones()` 

```python
np.ones_like(A)
# array([[1, 1, 1],
#        [1, 1, 1],
# 			 [1, 1, 1]])
```

### [13] 항등행렬(단위행렬) `identity()` , `eye()` 

```python
np.identity((2))
# array([[1., 0.],
#        [0., 1.]])

np.eye(3,4)
# array([[1., 0., 0., 0.],
#        [0., 1., 0., 0.],
#        [0., 0., 1., 0.]])

np.eye(3,4,1)
# array([[0., 1., 0., 0.],
#        [0., 0., 1., 0.],
#        [0., 0., 0., 1.]])
```

### [14] 같은 숫자로 다 차있는 행렬 만들기 `full()` 

```python
np.full((2, 3), 10)
# array([[10, 10, 10],
#        [10, 10, 10]])
```

### [15] 행렬 만들기(간격, 개수)

```python
np.arange(10)
# array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])

np.arange(1.0, 5.0, 0.5)
# array([1. , 1.5, 2. , 2.5, 3. , 3.5, 4. , 4.5])

np.linspace(2.0, 3.0, num=5)
# array([2.  , 2.25, 2.5 , 2.75, 3.  ])
```

### [16] 행렬 형태 바꾸기 `reshape()` 

```python
A = np.arange(4).reshape((2,2))
A
# array([[0, 1],
#        [2, 3]])

np.amin(A, axis = 0)
# array([0, 1])

np.amin(A, axis=1)
# array([0, 2])

np.amin(A, axis = 0)
# array([2, 3])

np.amin(A, axis=1)
# array([1, 3])
```

### [17] 행 또는 열에서 최댓값 최솟값을 뺀 `ptp` 

```python
np.ptp(A, axis=0) # 행 따라 열 값 출력
# array([2, 2])
```

### [18] 통계값 

```python
# 중앙값
np.median(B, axis=1)
# array([3., 4., 5.])

# 평균
np.mean(B, axis=0)
# array([3., 4., 5.])

# 분산
np.var(B, axis=0)
# array([6., 6., 6.])

# 표준편차
np.std(B, axis=1)
# array([0.81649658, 0.81649658, 0.81649658])
```

## 6. 인덱싱과 슬라이싱

- 행렬 변수[행, 열]
- 인덱싱을 하면 차원 수가 내려간다.

```python
a = np.arange(12).reshape((3, 4))
# array([[ 0,  1,  2,  3],
#        [ 4,  5,  6,  7],
# 			 [ 8,  9, 10, 11]])

a[0:2, 0:4]
a[:2]
# array([[0, 1, 2, 3],
#        [4, 5, 6, 7]])

a[0, 0] # 0행 0열
# 0

a[[0, 2], ]
# array([[ 0,  1,  2,  3],
#        [ 8,  9, 10, 11]])

a[:, [0, 1, 3]]
# array([[ 0,  1,  3],
#        [ 4,  5,  7],
#        [ 8,  9, 11]])
```

- 인덱싱을 하면 그 값을 복사한 것이지 그 위치를 가져온 것이 아니다.
- 슬라이싱을 해서 c라는 것을 만들었고 해당 위치 값을 바꾸면 원본도 바뀜

```python
c = a[1:3, 1:3]
# array([[ 5,  6],
#        [ 9, 10]])

c[0,0] = 100
a
# array([[  0,   1,   2,   3],
#        [  4, 100,   6,   7],
#        [  8,   9,  10,  11]])
```

### [1] 불리언 인덱싱

```python
a = np.arange(1, 7).reshape(3, 2)
# array([[1, 2],
#        [3, 4],
#        [5, 6]])

bool_idx = (a > 2)
bool_idx
# array([[False, False],
#        [ True,  True],
#        [ True,  True]])
```

- 위 조건을 만족했던 애들만 쏙 뽑아옴
- 인덱싱 했더니 2차원에서 1차원으로 줄어듦

```python
a[bool_idx]
# array([3, 4, 5, 6])
```

### [2] 정수 인덱싱

- 행렬 변수[[행1, 행2, 행3], [열1, 열2, 열3]]

```python
a[[0, 1, 2], [0, 1, 0]]
# array([1, 4, 5])

a[[0, 0], [1, 1]]
# array([2, 2])
```

## 7. 전치`Transpose` 

```python
x = np.array([[1, 2], [3, 4]])
# array([[1, 2],
#        [3, 4]])

x.T
# array([[1, 3],
#        [2, 4]])
```

- 1차원은 바뀌지 않음

```python
v = np.arange(6)
v.T
# array([0, 1, 2, 3, 4, 5])
```

## 8. 강제로 1차원 배열 만들기`ravel()` , `flatten()` 

```python
a
# array([[0, 1],
#        [2, 3],
#        [4, 5]])

np.ravel(a) #넘파이 함수
# array([0, 1, 2, 3, 4, 5])

a.ravel() #객체의 함수
# array([0, 1, 2, 3, 4, 5])

a.flatten() #a의 복사본
# array([0, 1, 2, 3, 4, 5])

np.flatten(a) #넘파이에는 이 모듈이 없음
# 에러남
```

## 9. concatenate 

- 행과 열, 즉 형태가 같아야 합쳐진다.

```python
a = np.array([[1, 2], [3,4]])
b = np.array([[5, 6]])

np.concatenate((a, b))
# array([[1, 2],
#        [3, 4],
#        [5, 6]])

np.concatenate((a, b.T), axis=1)
# array([[1, 2, 5],
#        [3, 4, 6]])
```

## 10. 행렬 연산

```python
x = np.array([[1, 2], [3, 4]])
y = np.array([[5, 6], [7, 8]])

# 더하기
x + y
# array([[ 6,  8],
#        [10, 12]])

np.add(x, y)
# array([[ 6,  8],
#        [10, 12]])

# 빼기
np.subtract(x, y)
# array([[-4, -4],
#        [-4, -4]])

# 곱하기
np.multiply(x, y)
# array([[ 5, 12],
#        [21, 32]])

# 나누기
np.divide(x, y)
# array([[0.2       , 0.33333333],
#        [0.42857143, 0.5       ]])

# 제곱근
np.sqrt(x)
# array([[1.        , 1.41421356],
#        [1.73205081, 2.        ]])
```

### [1] 내적

```python
x = np.array([[1, 2], [3, 4]])
y = np.array([[5, 6], [7, 8]])

v = np.array([9, 10])
w = np.array([11, 12])

v.dot(w)
# 219

np.dot(x, v)
# array([29, 67])

x.dot(y)
# array([[19, 22],
#        [43, 50]])
```

## 11. 브로드캐스트

- 차원이 같아야 연산 가능!

```python
x = np.array([
               [1, 2, 3],
               [4, 5, 6],
               [7, 8, 9],
               [10, 11, 12]
               ])
v = np.array([1, 0, 1])
y = np.empty_like(x)

x[0, :] # 1차원으로 낮아짐
# array([1, 2, 3])

x[0, :] + v
# array([2, 2, 4])
```

```python
y.shape[0] # y의 행 갯수
# 4

for i in range(y.shape[0]) :
  y[i, :] = x[i, :] + v

y

# array([[ 2,  2,  4],
#        [ 5,  5,  7],
#        [ 8,  8, 10],
#        [11, 11, 13]])
```

- 조금 더 발전!!
- `tile()` :  벡터를 쌓아서 2차원 백터 만들기!!

```python
vv = np.tile(v, (4, 1))
vv
# array([[1, 0, 1],
#        [1, 0, 1],
#        [1, 0, 1],
#        [1, 0, 1]])

y = x + vv
y
# array([[ 2,  2,  4],
#        [ 5,  5,  7],
#        [ 8,  8, 10],
#        [11, 11, 13]])
```

### [1] 조금 더 발전!!! 브로드캐스트!!

- 넘파이가 자동으로 맞춰줌~!!
- 그래도 합치려는 행렬끼리 형태가 맞아야 됨

```python
y = x + v
y
# array([[ 2,  2,  4],
#        [ 5,  5,  7],
#        [ 8,  8, 10],
#        [11, 11, 13]])
```

### [2] 형태가 맞지 않을 땐 가공하기

```python
v = np.array([1, 2, 3])
w = np.array([4, 5])
x = np.array([[1, 2, 3], [4, 5, 6]])

x + v
# array([[2, 4, 6],
#        [5, 7, 9]])

x.T + w
# array([[ 5,  9],
#        [ 6, 10],
#        [ 7, 11]])

(x.T + w).T
# array([[ 5,  6,  7],
#        [ 9, 10, 11]])

x + np.reshape(w, (2, 1))
# array([[ 5,  6,  7],
#        [ 9, 10, 11]])

w.reshape(2, 1) + x
# array([[ 5,  6,  7],
#        [ 9, 10, 11]])
```

## 12. 실습

### [1] 배열 만들기

- 2 * 2 & 초기화 하지 않은 배열 만들기

```python
np.empty((2,2))
# array([[4.63713575e-310, 2.14321575e-312],
#        [5.43472210e-322, 0.00000000e+000]])
```

- 동일한 shape의 다차원 배열 만들기(초기화 x)

```python
x = np.array([[1, 2, 3], [4, 5, 6]])
np.empty_like(x)

# array([[93856672562064,              0,              0],
#        [             0,              0,              0]])
```

- 크기가 3인 단위행렬 만들기(2가지)

```python
np.identity(3)
# array([[1., 0., 0.],
#        [0., 1., 0.],
#        [0., 0., 1.]])

np.eye(3)
# array([[1., 0., 0.],
#        [0., 1., 0.],
#        [0., 0., 1.]])
```

- 원소가 모두 1인 3*2 행렬 만들기

```python
np.ones((3, 2))
# array([[1., 1.],
#        [1., 1.],
#        [1., 1.]])
```

- 원소가 모두 1인 x와 shape이 같은 행렬 만들기

```python
x =np.arange(4)
np.ones_like(x)
# array([1, 1, 1, 1])
```

- 3*2 영행렬 만들기

```python
np.zeros((3, 2))
# array([[0., 0.],
#        [0., 0.],
#        [0., 0.]])
```

- x와 shape이 같은 영행렬 만들기

```python
np.zeros_like(x)
# array([0, 0, 0, 0])
```

- 모든 원소가 7인 2 * 5 행렬 만들기 (2가지)

```python
np.full((2, 5), 7)
# array([[7, 7, 7, 7, 7],
#        [7, 7, 7, 7, 7]])

np.ones((2, 5)) * 7
# array([[7, 7, 7, 7, 7],
#        [7, 7, 7, 7, 7]])
```

- 모든 원소가 7인 x와 shape이 같은 배열 만들기 (2가지)

```python
np.full_like(x, 7)
# array([7, 7, 7, 7])

np.ones_like(x) * 7
# array([7, 7, 7, 7])
```

- 리스트에서 array 만들기

```python
a = [1, 2, 3]
np.array(a)
# array([1, 2, 3])
```

- 리스트에서 float 형으로 array 만들기

```python
np.array([1., 2., 3.])
# array([1., 2., 3.])

np.array([1, 2, 3], dtype=float)
# array([1., 2., 3.])

a = [1, 2, 3]
np.asarray(a, float)
# array([1., 2., 3.])
```

- 1~100까지 짝수로 된 배열 생성

```python
np.arange(2, 101, 2)
# array([  2,   4,   6,   8,  10,  12,  14,  16,  18,  20,  22,  24,  26,
#         28,  30,  32,  34,  36,  38,  40,  42,  44,  46,  48,  50,  52,
#         54,  56,  58,  60,  62,  64,  66,  68,  70,  72,  74,  76,  78,
#         80,  82,  84,  86,  88,  90,  92,  94,  96,  98, 100])
```

- 3.0~10.0 까지 50개의 원소를 균일하게 배열 만들기

```python
np.linspace(3.0, 10.0, 50)
# array([ 3.        ,  3.14285714,  3.28571429,  3.42857143,  3.57142857,
#         3.71428571,  3.85714286,  4.        ,  4.14285714,  4.28571429,
#         4.42857143,  4.57142857,  4.71428571,  4.85714286,  5.        ,
#         5.14285714,  5.28571429,  5.42857143,  5.57142857,  5.71428571,
#         5.85714286,  6.        ,  6.14285714,  6.28571429,  6.42857143,
#         6.57142857,  6.71428571,  6.85714286,  7.        ,  7.14285714,
#         7.28571429,  7.42857143,  7.57142857,  7.71428571,  7.85714286,
#         8.        ,  8.14285714,  8.28571429,  8.42857143,  8.57142857,
#         8.71428571,  8.85714286,  9.        ,  9.14285714,  9.28571429,
#         9.42857143,  9.57142857,  9.71428571,  9.85714286, 10.        ])
```

### [2] 배열 다루기

- 열이 150개인 2차원 행렬 만들기

```python
x = np.ones((10, 10, 3)) # 10개, 10행, 3열
x.reshape(2, 150) #np.reshape(x, (2, 150))

# array([[1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.,
#         1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.,
#         1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.,
#         1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.,
#         1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.,
#         1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.,
#         1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.,
#         1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.,
#         1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.,
#         1., 1., 1., 1., 1., 1.],
#        [1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.,
#         1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.,
#         1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.,
#         1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.,
#         1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.,
#         1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.,
#         1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.,
#         1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.,
#         1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.,
#         1., 1., 1., 1., 1., 1.]])
```

- 1차원 배열 만들기 (3가지)

```python
x = np.array([[1, 2, 3], [4, 5, 6]])

x.ravel()
np.ravel(x)
x.flatten()
# array([1, 2, 3, 4, 5, 6])
```

- 배열 합치기

```python
x = np.array([[1, 2, 3], [4, 5, 6]])
y = np.array([[7, 8, 9], [10,11,12]])

np.concatenate((x, y), axis=1)
# array([[ 1,  2,  3,  7,  8,  9],
#        [ 4,  5,  6, 10, 11, 12]])

np.concatenate((x, y))
# array([[ 1,  2,  3],
#        [ 4,  5,  6],
#        [ 7,  8,  9],
#        [10, 11, 12]])
```

- 아래 x를 가지고 [0,0,1,1,2,2]인 배열 만들기

```python
x = np.array([0, 1, 2])

# np.repeat(x, 2)
x.repeat(2)
# array([0, 0, 1, 1, 2, 2])
```

- 아래 x에서 앞, 뒤의 0 제거하기

```python
x = np.array([0, 0, 0, 1, 2, 3, 0, 2, 1, 0])

np.trim_zeros(x)
# array([1, 2, 3, 0, 2, 1])
```

